"""
Virtual Try-On Service using Gemini 2.5 Flash Image Generation
Handles the AI-powered bag virtual try-on using Google's Gemini API
"""

import base64
import io
import shutil
from datetime import datetime
from pathlib import Path
from PIL import Image
import google.genai as genai

from app.config import VERTEX_PROJECT_ID, VERTEX_LOCATION, RESULTS_DIR


async def generate_tryon_image(model_path: Path, bag_path: Path, unique_id: str) -> str:
    """
    FreshOff-style Virtual Try-On using Gemini 2.5 Flash with Image Generation
    
    This function replicates the exact behavior of the FreshOff production system:
    - Accepts person image and bag image
    - Passes both as multimodal inputs to Gemini
    - Uses production-tested prompt for realistic virtual try-on
    - Returns e-commerce quality generated image
    
    Model: gemini-2.5-flash-image (Google Nano Banana - Image Generation)
    """
    
    print(f"ğŸ¨ Generating virtual try-on with Gemini...")
    
    try:
        # Load and convert images to RGB
        person_image = Image.open(model_path).convert("RGB")
        bag_image = Image.open(bag_path).convert("RGB")
        
        print(f"   ğŸ“¸ Loaded person image: {person_image.size}")
        print(f"   ğŸ‘œ Loaded bag image: {bag_image.size}")
        
        # Production-tested prompt - CRITICAL: preserve exact model, only add bag
        TRYON_PROMPT = """CRITICAL INSTRUCTIONS: Realistic Virtual Try-On


TASK: Synthesize the PERSON from Image 1 carrying the BAG from Image 2.


RULES FOR THE PERSON:
- Keep the face, hair, body, outfit, and background EXACTLY identical to Image 1.
- EXCEPTION: You MUST modify the position of ONE arm/hand to naturally hold the bag.
- The arm holding the bag should be extended downwards or bent slightly to support the bag's weight.
- Ensure the person has exactly TWO arms and TWO hands total. Do not add extra limbs.


RULES FOR THE BAG:
- The bag must hang naturally from the person's hand or wrist.
- Respect gravity: The bag should hang downwards, not float.
- Realistic lighting: Cast shadows from the bag onto the person's leg/body.
- The fingers must be visible wrapping around the bag's handle.


OUTPUT: A photorealistic e-commerce image where the person is naturally carrying the accessory."""


        # Configure Gemini client with Vertex AI
        print(f"   ğŸ”‘ Authenticating with Google...")
        if not VERTEX_PROJECT_ID:
            raise Exception("Service account not configured. Please check .env file.")
        
        print(f"   ğŸ“Œ Using Service Account with Vertex AI")
        print(f"   ğŸ“Œ Project: {VERTEX_PROJECT_ID}")
        print(f"   ğŸ“Œ Location: {VERTEX_LOCATION}")
        client = genai.Client(
            vertexai=True,
            project=VERTEX_PROJECT_ID,
            location=VERTEX_LOCATION
        )
        
        print(f"   âœ… Client initialized successfully")
        
        print(f"   ğŸ¤– Calling Gemini API...")
        print(f"   ğŸ“ Model: gemini-2.5-flash-image")
        print(f"   â³ Waiting for response (this may take 10-30 seconds)...")
        
        # Call Gemini with multimodal inputs: [prompt, person, bag]
        # Order matters: prompt first, then person image, then bag image
        # This is the core FreshOff virtual try-on logic
        response = client.models.generate_content(
            model="gemini-2.5-flash-image",
            contents=[TRYON_PROMPT, person_image, bag_image],
            config={
                "response_modalities": ["IMAGE"],
                "temperature": 0.4,  # Lower temperature for more consistent results
            }
        )
        
        print(f"   âœ… Received response from Gemini")
        print(f"   ğŸ“¦ Response type: {type(response)}")
        print(f"   ğŸ“Š Candidates: {len(response.candidates) if response.candidates else 0}")
        
        # Extract the generated image from response
        # Gemini returns image as inline data
        if not response.candidates:
            print(f"   âŒ No candidates in response")
            raise Exception("No image generated by Gemini")
        
        print(f"   ğŸ” Extracting image from response...")
        generated_image_data = None
        for i, part in enumerate(response.candidates[0].content.parts):
            print(f"   ğŸ“„ Part {i}: {type(part)}, has inline_data: {hasattr(part, 'inline_data')}")
            if hasattr(part, 'inline_data') and part.inline_data:
                generated_image_data = part.inline_data.data
                print(f"   âœ… Found image data in part {i}")
                break
        
        if not generated_image_data:
            print(f"   âŒ No inline_data found in response parts")
            raise Exception("No image data found in Gemini response")
        
        # Save generated image
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        tryon_filename = f"tryon_{timestamp}_{unique_id}.jpg"
        tryon_path = RESULTS_DIR / tryon_filename
        
        # Handle image data - might be bytes or base64 string
        print(f"   ğŸ’¾ Saving generated image...")
        print(f"   ğŸ“ Data type: {type(generated_image_data)}")
        
        if isinstance(generated_image_data, bytes):
            # Data is already bytes
            image_bytes = generated_image_data
            print(f"   âœ… Data is already bytes: {len(image_bytes)} bytes")
        elif isinstance(generated_image_data, str):
            # Data is base64 encoded string
            image_bytes = base64.b64decode(generated_image_data)
            print(f"   âœ… Decoded from base64: {len(image_bytes)} bytes")
        else:
            raise Exception(f"Unexpected data type: {type(generated_image_data)}")
        
        # Open and save the image
        generated_image = Image.open(io.BytesIO(image_bytes))
        generated_image.save(tryon_path, "JPEG", quality=95)
        
        print(f"   âœ… Virtual try-on generated: {tryon_filename}")
        print(f"   ğŸ’¾ Saved to: {tryon_path}")
        
        return f"/static/results/{tryon_filename}"
        
    except Exception as e:
        print(f"   âŒ Error during try-on generation: {str(e)}")
        print(f"   ğŸ“‹ Error type: {type(e).__name__}")
        import traceback
        print(f"   ğŸ“‹ Full traceback:")
        traceback.print_exc()
        # Fallback: return original model image if generation fails
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        tryon_filename = f"tryon_fallback_{timestamp}_{unique_id}.jpg"
        tryon_path = RESULTS_DIR / tryon_filename
        shutil.copy(model_path, tryon_path)
        print(f"   âš ï¸  Fallback: Using original model image")
        return f"/static/results/{tryon_filename}"
